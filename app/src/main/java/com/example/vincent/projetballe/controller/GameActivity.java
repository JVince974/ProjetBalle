package com.example.vincent.projetballe.controller;import android.app.Activity;import android.content.Intent;import android.hardware.Sensor;import android.hardware.SensorEvent;import android.hardware.SensorEventListener;import android.hardware.SensorManager;import android.os.Bundle;import android.os.CountDownTimer;import android.util.Log;import android.view.GestureDetector;import android.view.MotionEvent;import android.widget.TextView;import com.example.vincent.projetballe.R;import com.example.vincent.projetballe.bibliotheque.MyMediaPlayer;import com.example.vincent.projetballe.model.GameObject.lesBalles.CatchBalle;import com.example.vincent.projetballe.model.GameObject.lesBalles.EnnemyBalle;import com.example.vincent.projetballe.model.GameObject.lesBalles.ShieldBalle;import com.example.vincent.projetballe.model.GameObject.lesBalles.UserBalle;import com.example.vincent.projetballe.model.GameObject.lesBonus.BonusMalus;import com.example.vincent.projetballe.view.AnimateGameView;import java.util.ArrayList;import java.util.ConcurrentModificationException;import java.util.Iterator;/** * Cette classe gère le déplacement de la balle de l'utilisateur à l'aide de l'accéléromètre * Elle instancie toutes les balles * Elle gére toutes les interaction de la balle avec les autres objets et l'environnement * ex : collision avec une autre balle, prendre un bonus, etc. */public class GameActivity extends Activity implements SensorEventListener {    private static final String TAG = "GameActivity";    public static final String MY_INTENT_EXTRA_SCORE = "score"; // Variable intent pour récupérer le score    // les views    private AnimateGameView mAnimateGameView;    private TextView tvInfoPlayer;    private TextView tvTime;    // Accéléromètre    private SensorManager mSensorManager;    private Sensor mAccelerometer;    private MyMediaPlayer mMediaPlayer; // pour jouer la musique de fond    // taille de l'écran    private int viewWidth;    private int viewHeight;    // tous les objets du jeu    private UserBalle mUserBalle;    private ArrayList<EnnemyBalle> mEnnemyBalleArrayList = new ArrayList<>();    private CatchBalle mCatchBalle;    private BonusMalus mBonus;    private ArrayList<ShieldBalle> mShieldBalleArrayList = new ArrayList<>();    // les chronomètres    private CountDownTimer mCountDownTimerBonus; // Chronomètre qui fait apparaitre des bonus    private CountDownTimer mcdtChronometer; // chronometer qui affiche le décompte du bonus    private final static long BONUS_TIMER_APPEAR = 7 * 1000; // 7 sec    // gestion de l'état du jeu    private boolean started = false; // gère le start/resume    private boolean gamerOver = false;    private boolean alreadyScored = false; // booléen qui permet de ne pas marquer plein de points d'affiler lorsque le joueur touche la balle de score    // infos du joueur    private int life = 3;    private int score = 0;    // gestion des ennemis    private int numberEnnemyBalle = 3; // nombre de balles adverses sur le jeu    private float iaBallSpeed = 1; // vitesse des balles adverses augmentent avec le temps    private final int maxSpeed = 7;    // gestion des bonus malus    private boolean accelerometerInversed = false; // pour le malus qui inverse l'accelerometer    /**     * Récupérer les vues     * Instancier toutes les variables     */    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_game);        // récupérer la vue        mAnimateGameView = (AnimateGameView) findViewById(R.id.animate_game_view);        mAnimateGameView.setKeepScreenOn(true); // empecher la mise en veille du téléphone        tvInfoPlayer = (TextView) findViewById(R.id.tv_info_player);        tvTime = (TextView) findViewById(R.id.tv_time);        displayInfoPlayer();        // le sensor        mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);//        mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);        mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY);        mMediaPlayer = new MyMediaPlayer(this, R.raw.rayman_ost);        // lister tous les sensors du téléphone//        List<Sensor> sensorsList = mSensorManager.getSensorList(Sensor.TYPE_ALL);//        for (Sensor s : sensorsList) {//            Log.d("SensorAvailable", "" + s.toString());//        }    }    /**     * Arreter tous les threads, la musique et l'accéléromètre     */    @Override    protected void onDestroy() {        super.onDestroy();        // mettre en pause toutes les balles        for (EnnemyBalle ennemyBalle : mEnnemyBalleArrayList) {            ennemyBalle.stop();        }        mCatchBalle.stop();        for (ShieldBalle shieldBalle : mShieldBalleArrayList) {            shieldBalle.stop();        }        mSensorManager.unregisterListener(this);        mMediaPlayer.stop();    }    /**     * Récupère la taille de l'écran     * Lance la partie ou le met en pause     */    @Override    public void onWindowFocusChanged(boolean hasFocus) {        Log.d(TAG, "onWindowFocusChanged() called with: hasFocus = [" + hasFocus + "]");        super.onWindowFocusChanged(hasFocus);        if (hasFocus) {            if (!started) {                gameStart();                started = true;            } else {                gameResume();            }        } else {            if (!gamerOver) {                gamePause();            }        }    }    /**     * Appuyer 2 fois pour quitter     */    @Override    public void onBackPressed() {//        Toast.makeText(this, getResources().getString(R.string.double_tap_for_exit), Toast.LENGTH_SHORT).show();        gameOver();        super.onBackPressed();    }    @Override    public boolean onTouchEvent(MotionEvent event) {        int pointerId = event.getPointerId(0);        int pointerIndex = event.findPointerIndex(pointerId);        // Get the pointer's current position        float x = event.getX(pointerIndex);        float y = event.getY(pointerIndex);        Log.v(TAG, "onTouchEvent() called with: X = [" + x + "], Y = [" + y + "]");        if (mUserBalle.hasShield()) {            for (ShieldBalle shieldBalle : mShieldBalleArrayList) {                shieldBalle.setDefending(false);            }        }        return super.onTouchEvent(event);    }    final GestureDetector gestureDetector = new GestureDetector(new GestureDetector.SimpleOnGestureListener() {        public void onLongPress(MotionEvent e) {            Log.e("", "Longpress detected");        }    });    /**     * Analyse chaque interaction de la balle avec l'environnement     * ex : collision avec une autre balle, récupération d'un bonus     * Envoyer le score au main activity en fin de partie     */    private void onUserBalleMovedListener() {        if (mUserBalle.hasShield()) {            collisionShieldBalle();        }        collisionEnnemyBalle();        collisionCatchBalle();        // Quand on touche un bonus, cacher le bonus        collisionBonusMalus();    }    /**     * Vérifie la collision entre les balles ennemies et les balles boucliers     */    private void collisionShieldBalle() {        for (Iterator itShieldBalle = mShieldBalleArrayList.iterator(); itShieldBalle.hasNext(); ) {            ShieldBalle shieldBalle = (ShieldBalle) itShieldBalle.next();            for (Iterator itEnnemyBalle = mEnnemyBalleArrayList.iterator(); itEnnemyBalle.hasNext(); ) {                EnnemyBalle ennemyBalle = (EnnemyBalle) itEnnemyBalle.next();                if (shieldBalle.touched(ennemyBalle)) {                    shieldBalle.destroy();                    ennemyBalle.destroy();                }            }        }        resetShieldBalles();    }    // vérifier les collisions avec chaque balles ennemies    // si touché, si la balle est grosse détruire les balles adverses    // sinon perdre un point de vie    private void collisionEnnemyBalle() {        try {            for (EnnemyBalle ennemyBalle : mEnnemyBalleArrayList) {                if (mUserBalle.touched(ennemyBalle)) {                    if (mUserBalle.hasEatProtein()) { // bonus protein                        // Détruire la balle et faire réapparaitre une plus tard                        ennemyBalle.destroy();                        break;                    } else if (!mUserBalle.isInvincible()) {                        // sinon perdre une vie                        life--;                        displayInfoPlayer();                        mUserBalle.flash();                        if (life < 1)                            gameOver(); // TODO: 01/11/2017 reactiver                        break;                    }                }            }        } catch (ConcurrentModificationException e) {            e.printStackTrace();        }        resetEnnemyBalles();    }    // lorsqu'on touche la balle a attraper    // augmente le score et augmenter la vitesse des balles    private void collisionCatchBalle() {        if (mUserBalle.touched(mCatchBalle)) {            if (!mCatchBalle.isAnimating()) {                if (!alreadyScored) { // pour éviter d'enchainer les points lorsque l'utilisateur touche la balle                    alreadyScored = true;                    score += mCatchBalle.getScore();                    displayInfoPlayer();                    // Détruire la catch balle et faire réapparaitre une plus tard                    new Thread(new Runnable() {                        @Override                        public void run() {                            if (iaBallSpeed < maxSpeed) iaBallSpeed *= 1.2;                            Log.v(TAG, "iaBallSpeed : " + iaBallSpeed);                            mCatchBalle.destroy();                            try {                                Thread.sleep(1);                            } catch (InterruptedException e) {                                e.printStackTrace();                            }                            resetCatchBalle();                            alreadyScored = false;                        }                    }).start();                }            }        }    }    // Quand on touche un bonus, cacher le bonus    private void collisionBonusMalus() {        if (mBonus != null) {            if (mUserBalle.touched(mBonus)) {                Log.d(TAG, "onUserBalleMovedListener: UserBalle touched Bonus");                mBonus.move(viewWidth + 1000, viewHeight + 1000);                mBonus.start();            }        }    }    /**     * Enlève toutes les balles shield arrêté, met a false le bouclier de l'utilisateur s'il n'y a plus de balles     */    public void resetShieldBalles() {        // enlever les balles inutiles        for (Iterator<ShieldBalle> iterator = mShieldBalleArrayList.iterator(); iterator.hasNext(); ) {            ShieldBalle shieldBalle = iterator.next();            if (shieldBalle.isOut()) iterator.remove();        }        if (mShieldBalleArrayList.size() == 0) {            mUserBalle.setShield(false);        }    }    /**     * Enlève toutes les balles ennemies arrêté et les recréer     */    public void resetEnnemyBalles() {        // enlever les balles inutiles        for (Iterator<EnnemyBalle> iterator = mEnnemyBalleArrayList.iterator(); iterator.hasNext(); ) {            EnnemyBalle ennemyBalle = iterator.next();            if (ennemyBalle.isOut()) iterator.remove();        }        // Recréer les balles        while (mEnnemyBalleArrayList.size() < numberEnnemyBalle) {            EnnemyBalle ennemyBalle = EnnemyBalle.randomEnnmyBalle(this, mUserBalle.getDefaultRadius());            mEnnemyBalleArrayList.add(ennemyBalle);            ennemyBalle.start();        }    }    /*     * Recréer la balle a attraper     */    public void resetCatchBalle() {        mCatchBalle = CatchBalle.randomCatchBalle(GameActivity.this, mCatchBalle.getDefaultRadius());        mCatchBalle.start();    }    /**     * Lance un décompte et lance un nouveau bonus ou malus sur le terrain     */    // TODO: 02/11/2017 reactiver    public void resetBonusMalus() {        runOnUiThread(new Runnable() {            @Override            public void run() {                mCountDownTimerBonus = new CountDownTimer(BONUS_TIMER_APPEAR, 1000) {                    @Override                    public void onTick(long millisUntilFinished) {                        int seconds = (int) (millisUntilFinished / 1000);                        Log.v(TAG, "Next bonus in : " + String.format("%02d", seconds));                    }                    @Override                    public void onFinish() {                        mBonus = BonusMalus.randomBonusMalus(GameActivity.this); // exemple                    }                }.start();            }        });    }    /**     * Récupérer la taille de la view     * Instancier la balle utilisateur     * Instancier les balles ia     * Instancier la balle à attraper     * Lancer le controleur de jeu,     * Lancer l'accelerometre     * Lancer la musique     */    private void gameStart() {        Log.d(TAG, "Starting game...");        viewWidth = mAnimateGameView.getWidth();        viewHeight = mAnimateGameView.getHeight();        Log.d("WindowsSize", "Width=[" + viewWidth + "], Height=[" + viewHeight + "]");        // Instancier toutes les balles        // positionner la balle utilisateur au milieu de l'écran        mUserBalle = new UserBalle(viewWidth / 2, viewHeight / 2, (int) (viewWidth * 4.63 / 100), viewWidth, viewHeight);        // TODO: 30/10/2017 toDelete        debug();        // ennemies        while (mEnnemyBalleArrayList.size() < numberEnnemyBalle) { // ajouter des balles ia            EnnemyBalle ennemyBalle = EnnemyBalle.randomEnnmyBalle(this, mUserBalle.getDefaultRadius());            mEnnemyBalleArrayList.add(ennemyBalle);            ennemyBalle.start();        }        // la balle a attraper        mCatchBalle = CatchBalle.randomCatchBalle(this, mUserBalle.getDefaultRadius());        mCatchBalle.start();        resetBonusMalus(); // créer le compte a rebours pour faire apparaitre le bonus        mAnimateGameView.setGameActivity(this); // permet a la vue de récupérer tous les objets de la gameActivity pour dessiner        mSensorManager.registerListener(this, mAccelerometer, SensorManager.SENSOR_DELAY_GAME);        mMediaPlayer.start();    }    /**     * Mettre en pause toutes les balles     * Continuer l'accéléromètre et relancer les balles IA     * Remettre la musique     */    private void gameResume() {        Log.d(TAG, "Resuming game...");        // resume toutes les balles        for (EnnemyBalle ennemyBalle : mEnnemyBalleArrayList) {            ennemyBalle.resume();        }        mCatchBalle.resume();        for (ShieldBalle shieldBalle : mShieldBalleArrayList) {            shieldBalle.resume();        }        mSensorManager.registerListener(this, mAccelerometer, SensorManager.SENSOR_DELAY_GAME);        mMediaPlayer.resume();    }    /**     * Mettre en pause l'accéléromètre et les balles IA     * mettre en pause la musique     */    private void gamePause() {        Log.d(TAG, "Pausing game...");        // mettre en pause toutes les balles        for (EnnemyBalle ennemyBalle : mEnnemyBalleArrayList) {            ennemyBalle.pause();        }        mCatchBalle.pause();        for (ShieldBalle shieldBalle : mShieldBalleArrayList) {            shieldBalle.pause();        }        mSensorManager.unregisterListener(this);        mMediaPlayer.pause();    }    /**     * Arreter tous les threads, la musique et l'accéléromètre     * Envoyer le score au main activity     */    private void gameOver() {        Log.d(TAG, "Game Over : score = " + score);        gamerOver = true;        // Envoyer le score au main Activity        Intent intent = new Intent(this, MainActivity.class);        intent.putExtra(MY_INTENT_EXTRA_SCORE, score);        if (score > 0)            setResult(Activity.RESULT_OK, intent);        finish();    }    /**     * Afficher le score     */    public void displayInfoPlayer() {        runOnUiThread(new Runnable() {            @Override            public void run() {                tvInfoPlayer.setText(getResources().getString(R.string.score) + " : " + GameActivity.this.score                        + "\n " + getResources().getString(R.string.life) + " : " + GameActivity.this.life);            }        });    }    /**     * Afficher le décompte d'un chronomère pour les bonus     */    public void displayCronometer(final long time) {        runOnUiThread(new Runnable() {            @Override            public void run() {                // Créer le timer                mcdtChronometer = new CountDownTimer(time, 1000) {                    @Override                    public void onTick(long millisUntilFinished) {                        int seconds = (int) (millisUntilFinished / 1000);                        tvTime.setText(String.format("%02d", seconds));                    }                    @Override                    public void onFinish() {                        tvTime.setText("");                    }                }.start();            }        });    }    /**     * Bouger la balle avec l'accéléromètre     */    @Override    public void onSensorChanged(SensorEvent event) {//        Log.v(TAG, "onSensorChanged:  x=" + event.values[0] + ", y=" + event.values[1]);        if (mUserBalle != null) {            // Si la personne a pris un malus qui inverse l'accéléromètre            if (accelerometerInversed)                mUserBalle.move((int) (mUserBalle.getPosX() + event.values[0] * mUserBalle.getSpeed()), (int) (mUserBalle.getPosY() - event.values[1] * mUserBalle.getSpeed()));            else                mUserBalle.move((int) (mUserBalle.getPosX() - event.values[0] * mUserBalle.getSpeed()), (int) (mUserBalle.getPosY() + event.values[1] * mUserBalle.getSpeed()));            onUserBalleMovedListener();        } else {            Log.w(TAG, "onSensorChanged: UserBall est null, vérifié que vous avez instancié correctement");        }    }    @Override    public void onAccuracyChanged(Sensor sensor, int accuracy) {    }    /*     * GETTER AND SETTERS     */    public int getViewWidth() {        return viewWidth;    }    public int getViewHeight() {        return viewHeight;    }    public UserBalle getUserBalle() {        return mUserBalle;    }    public ArrayList<EnnemyBalle> getEnnemyBalleArrayList() {        return mEnnemyBalleArrayList;    }    public CatchBalle getCatchBalle() {        return mCatchBalle;    }    public BonusMalus getBonus() {        return mBonus;    }    public ArrayList<ShieldBalle> getShieldBalleArrayList() {        return mShieldBalleArrayList;    }    public float getIaBallSpeed() {        return iaBallSpeed;    }    public void setIaBallSpeed(float iaBallSpeed) {        this.iaBallSpeed = iaBallSpeed;    }    public MyMediaPlayer getMediaPlayer() {        return mMediaPlayer;    }    public int getLife() {        return life;    }    public void setLife(int life) {        this.life = life;    }    public void setAccelerometerInversed(boolean accelerometerInversed) {        this.accelerometerInversed = accelerometerInversed;    }    /**     * DEBUG     */    private void debug() {//        mBonus = Bonus.debugWhichBonus(this, Bonus.BONUS_STOP_IA_BALLS);//        iaBallSpeed = 5;//        numberEnnemyBalle = 1;//        mBonus = Bonus.debugWhichBonus(this, Bonus.BONUS_SHIELD_BALLS); // exemple//        mBonus = Malus.debugWhichMalus(this, Malus.MALUS_DIVISION);//        mBonus.start();//        ShieldBalle shieldBalleLeft = ShieldBalle.randomShieldBalle(this, mUserBalle.getDefaultRadius(), mUserBalle.getPosX() - mUserBalle.getDefaultRadius() * 2, mUserBalle.getPosY());//        ShieldBalle shieldBalleRight = ShieldBalle.randomShieldBalle(this, mUserBalle.getDefaultRadius(), mUserBalle.getPosX() + mUserBalle.getDefaultRadius() * 2, mUserBalle.getPosY());//        ShieldBalle shieldBalleUp = ShieldBalle.randomShieldBalle(this, mUserBalle.getDefaultRadius(), mUserBalle.getPosX(), mUserBalle.getPosY() - mUserBalle.getDefaultRadius() * 2);//        ShieldBalle shieldBalleDown = ShieldBalle.randomShieldBalle(this, mUserBalle.getDefaultRadius(), mUserBalle.getPosX(), mUserBalle.getPosY() + mUserBalle.getDefaultRadius() * 2);////        mShieldBalleArrayList.add(shieldBalleLeft);//        mShieldBalleArrayList.add(shieldBalleRight);//        mShieldBalleArrayList.add(shieldBalleUp);//        mShieldBalleArrayList.add(shieldBalleDown);////        shieldBalleLeft.start();//        shieldBalleRight.start();//        shieldBalleUp.start();//        shieldBalleDown.start();////        mUserBalle.setShield(true);    }}